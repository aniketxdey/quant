# Introduction to C++ for Financial Engineers: An Object-Oriented Approach
## Chapter 2: The Mechnaics of C++ - from Source Code to a Running Program
- Define syntax to create and run simple programs, and understand how they are run

## 2.2 The Compilation Process
- C++ language is detailed in Stroustoup
- A compiler is an executable program that accepts a text file containing C++ 
    - Translates code into a form that eventually executes in a computer
    - We split a problem into independent pieces or modules - each module is implelemnted by valid C++ code - ex: C/C++ function or a C++ class
- Each module is implelemted by a C/C++ function or C++ class in the code
- Create two files - one with declaration of all functions and data with the other file being the actual code body of each function
    - Header file: contains declarations of all functions and data
    - Code file: the file containing the actual body of all functions
- Variations on & exceptions to this strategy
- Header file typiclaly contains the declaration of all functions and data that we are going to use
    - In the case of functions, we define the signature of a fucntion as consisting of: name, return type, and input arguments
    - In the case of daa




## 1.3 Multi-Paradigm Analysis
### Object-Oriented Paradigm
- Based on the concept off a class which has origins in philosophy, logic, and psychology
- Theory of concepts has been an important influence on the development of the object paradigm
- Classes consist of data and functions, and we create objects or so-called instances of the class by initializing the data in the class
### Generic Programming
- Paradigm that is a competitor of the object-oriented paradigm
- Not focused on hard-wired data types - design software with generic underlying types, and instantiate or clone the entity by replacing types later on
### Procedural, modular, and functional programming
- Fortran is useful for formula transformation in math/engineering apps

## 1.5 Software Quality
Six Characteristics:
1. Functionality - functionality of a system to satisfy user needs - includes accuracy, sutiability, interoperability, compliance, security
2. Reliability - maintaining a given level of performance over time - includes maturity, fault tolerance, recoverability
3. Usability - effort needed to use an application or system - includes understandability, learnability, and operability
4. Efficiency - Kevel of performance and amount of resources needed to reach performance 
5. Maintainability - effort needed to make modifications
6. Portability - ability to be transferred from one environment to another

